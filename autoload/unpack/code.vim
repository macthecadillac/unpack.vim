function! s:gen_augroup(name, defs)
  let l:output = []
  for [l:type, l:filters, l:cmd] in a:defs
    for l:filter in l:filters
      call add(l:output, '  autocmd ' . l:type . ' ' . l:filter . ' ' . l:cmd)
    endfor
  endfor
  return l:output
endfunction

function! s:gen_pre_post(exe)
  if a:exe ==# ''
    return []
  elseif type(a:exe) ==# 1  " string
    return ['    execute "' . a:exe . '"']
  elseif type(a:exe) ==# 2  " lambda
    return ['    call ' . a:exe . '()']
  else
    let error = '"setup" must be either a funcref or a string'
    return []
  endif
endfunction

" rename package names that contain '.' and '-' to '_'
function! s:rename(name)
  return substitute(tolower(a:name), '\(\.\|-\)', '_', 'g')
endfunction

function! s:gen_loader(name, state)
  let l:output = []
  let l:name = s:rename(a:name)
  let l:flag = 'g:unpack_loader_' . l:name . '_init_status'
  call add(l:output, 'let ' . l:flag . ' = 0')
  call add(l:output, 'function! unpack#loader#' . l:name . '()')
  call add(l:output, '  if !' . l:flag)
  call add(l:output, '    let ' . l:flag . ' = 1')

  call extend(l:output, s:gen_pre_post(get(a:state.setup, a:name, '')))
  call add(l:output, '    execute "packadd ' . a:name . '"')
  call extend(l:output, s:gen_pre_post(get(a:state.config, a:name, '')))

  call add(l:output, '  endif')
  call add(l:output, 'endfunction')
  return l:output
endfunction

function! s:gen_item(name, state)
  let l:defs = []
  let l:name = s:rename(a:name)
  let l:cmd = 'call unpack#loader#' . l:name . '()'

  for [l:type, l:key] in [['FileType', 'ft'], ['CmdUndefined', 'cmd']]
    if has_key(a:state[l:key], a:name)
      call add(l:defs, [l:type, a:state[l:key][a:name], l:cmd])
    endif
  endfor

  if has_key(a:state.event, a:name)
    for l:event in a:state.event[a:name]
      call add(l:defs, [l:event, ['*'], l:cmd])
    endfor
  endif

  let l:output = {}
  let l:output.loader = s:gen_loader(a:name, a:state)
  let l:output.groupdef = s:gen_augroup(toupper(l:name), l:defs)
  return l:output
endfunction

function! unpack#code#gen(state, configuration)
  let l:output = {
        \   'loader': [],
        \   'unplug': [],
        \   'ftplugin': {},
        \ }
  call add(l:output.loader, '" autogenerated by unpack#compile()')
  if g:unpack#packpath_modified
    call add(l:output.loader, 'set packpath+=' . g:unpack#packpath)
  endif
  let l:groupdef = []
  call add(l:groupdef, 'augroup UNPACK_AUTOLOAD')
  call add(l:groupdef, '  autocmd!')
  for l:name in keys(a:configuration.packages)
    let l:item_code = s:gen_item(l:name, a:state)
    call extend(l:output.loader, l:item_code.loader)
    call extend(l:groupdef, l:item_code.groupdef)
  endfor
  call add(l:groupdef, 'augroup END')
  call extend(l:output.loader, l:groupdef)
  call add(l:output.unplug, '" autogenerated by unpack#compile()')
  call add(l:output.unplug, '" place-holder to bypass calling unpack')
  call add(l:output.unplug, 'function! unplug#begin()')
  call add(l:output.unplug, 'endfunction')
  call add(l:output.unplug, 'function! unplug#end()')
  call add(l:output.unplug, 'endfunction')
  call add(l:output.unplug, 'command! -nargs=0 Unpack echo ""')
  return l:output
endfunction
