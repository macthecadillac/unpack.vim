function! s:gen_augroup(name, defs)
  let l:output = ['augroup ' . a:name]
  for [l:type, l:filters, l:cmd] in a:defs
    for l:filter in l:filters
      call add(l:output, '  autocmd ' . l:type . ' ' . l:filter . ' ' . l:cmd)
    endfor
  endfor
  return add(l:output, 'augroup END')
endfunction

function! s:gen_pre_post(exe)
  if a:exe ==# ''
    return []
  elseif type(a:exe) ==# 1  " string
    return ['    execute "' . a:exe . '"']
  elseif type(a:exe) ==# 2  " lambda
    return ['    call ' . a:exe . '()']
  else
    let error = '"setup" must be either a lambda or a string'
    return []
  endif
endfunction

function! s:gen_loader(name, state)
  let l:output = []
  let l:name = substitute(tolower(a:name), '\.', '_', 'g')
  let l:flag = 'g:unpack_loader_' . l:name . '_init_status'
  call add(l:output, 'let ' . l:flag . ' = 0')
  call add(l:output, 'function! unpack#loader#' . l:name . '()')
  call add(l:output, '  if !' . l:flag)
  call add(l:output, '    let ' . l:flag . ' = 1')

  call extend(l:output, s:gen_pre_post(get(a:state.setup, a:name, '')))
  call add(l:output, '    execute "packadd ' . a:name . '"')
  call extend(l:output, s:gen_pre_post(get(a:state.config, a:name, '')))

  call add(l:output, '  endif')
  call add(l:output, 'endfunction')
  return l:output
endfunction

function! s:gen_item(name, state)
  let l:output = []
  let l:defs = []
  let l:name = substitute(tolower(a:name), '\.', '_', 'g')
  let l:cmd = 'call unpack#loader#' . l:name . '()'

  for [l:type, l:key] in [['FileType', 'ft'], ['CmdUndefined', 'cmd']]
    if has_key(a:state[l:key], a:name)
      call add(l:defs, [l:type, a:state[l:key][a:name], l:cmd])
    endif
  endfor

  if has_key(a:state.event, a:name)
    for l:event in a:state.event[a:name]
      call add(l:defs, [l:event, ['*'], l:cmd])
    endfor
  endif

  return extend(s:gen_loader(a:name, a:state), s:gen_augroup(toupper(l:name), l:defs))
endfunction

function! unpack#code#gen(state)
  let l:output = []
  call add(l:output, '" autogenerated by unpack#compile()')
  if s:packpath_modified
    call add(l:output, 'set packpath+=' . g:unpack#packpath)
  endif
  for l:name in keys(s:configuration.packages)
    call extend(l:output, s:gen_item(l:name, a:state))
  endfor
  return l:output
endfunction
