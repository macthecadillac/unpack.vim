function! s:gen_aucmds(defs)
  let l:output = []
  for [l:type, l:filters, l:cmd] in a:defs
    for l:filter in l:filters
      call add(l:output, '  autocmd ' . l:type . ' ' . l:filter . ' ' . l:cmd)
    endfor
  endfor
  return l:output
endfunction

function! s:gen_pre_post(cmd, ...)
  let l:padding = a:0 ? repeat(' ', a:1) : ''
  if a:cmd ==# ''
    return []
  else
    if stridx(a:cmd, '"')
      return [l:padding . "execute '" . a:cmd . "'"]
    else
      return [l:padding . 'execute "' . a:cmd . '"']
    endif
  endif
endfunction

" rename package names that contain '.' and '-' to '_'
function! s:rename(name)
  return substitute(tolower(a:name), '\(\.\|-\)', '_', 'g')
endfunction

" FIXME: this won't work if the dependency has filetypes defined
function! s:gen_optional_loader(name, configuration)
  let l:spec = a:configuration.packages[a:name]
  let l:output = []
  let l:name = s:rename(a:name)
  call add(l:output,   "  if !get(g:, 'unpack_loader_" . l:name . "_init_status', v:false)")
  call add(l:output, "    let g:unpack_loader_" . l:name . "_init_status = v:true")
  for l:dep in l:spec.requires
    if unpack#solv#is_optional(a:name, a:configuration)
      call add(l:output, '    call unpack#loader#' . s:rename(l:dep) . '()')
    endif
  endfor
  call extend(l:output, s:gen_pre_post(l:spec['pre'], 4))
  call add(l:output, "    execute 'packadd " . a:name . "'")
  call extend(l:output, s:gen_pre_post(l:spec['post'], 4))
  call add(l:output, '  endif')
  return l:output
endfunction

function! s:gen_loader(name, configuration)
  let l:output = []
  let l:spec = a:configuration.packages[a:name]
  " we use ftplugins for filetype options to save on overhead
  if !empty(l:spec.cmd) || !empty(l:spec.event) || l:spec.opt
    let l:name = s:rename(a:name)
    call add(l:output, 'function! unpack#loader#' . l:name . '()')
    call extend(l:output, s:gen_optional_loader(a:name, a:configuration))
    call add(l:output, 'endfunction')
  elseif empty(l:spec.ft)
    if l:spec['pre'] !=# ''
      call extend(l:output, s:gen_pre_post(l:spec['pre']))
      call add(l:output, "execute 'packadd " . a:name . "'")
    endif
    call extend(l:output, s:gen_pre_post(l:spec['post']))
  endif
  return l:output
endfunction

function! s:gen_autoload_item(name, configuration)
  let l:spec = a:configuration.packages[a:name]
  let l:defs = []
  let l:name = s:rename(a:name)
  let l:loader_cmd = 'call unpack#loader#' . l:name . '()'

  if !empty(l:spec.cmd)
    call add(l:defs, ['CmdUndefined', l:spec.cmd, l:loader_cmd])
  endif

  for l:event in l:spec.event
    call add(l:defs, [l:event, ['*'], l:loader_cmd])
  endfor

  let l:output = {}
  let l:output.loader = s:gen_loader(a:name, a:configuration)
  let l:output.groupdef = s:gen_aucmds(l:defs)
  return l:output
endfunction

function! s:gen_ft_item(name, configuration)
  let l:output = {}
  let l:spec = a:configuration.packages[a:name]
  for l:ft in l:spec.ft
    "                                                               remove indentation
    let l:output[l:ft] = map(s:gen_optional_loader(a:name, a:configuration), {_, s -> s[2:]})
  endfor
  return l:output
endfunction

function! s:needs_loader(name, config)
  let l:spec = a:config.packages[a:name]
  return l:spec['post'] !=# '' || l:spec['pre'] !=# '' || unpack#solv#is_optional(a:name, a:config)
endfunction

function! unpack#code#gen(configuration)
  let l:output = {
        \   'plugin': { 'unpack': [] },
        \   'ftplugin': {},
        \   'autoload': { 'unpack': { 'loader': [] } }
        \ }
  call add(l:output.plugin.unpack, '" autogenerated by unpack#compile()')
  call add(l:output.autoload.unpack.loader, '" autogenerated by unpack#compile()')
  if g:unpack#packpath_modified
    call add(l:output.plugin.unpack, 'set packpath+=' . g:unpack#packpath)
  endif
  let l:groupdef = []
  call add(l:groupdef, 'augroup UNPACK_AUTOLOAD')
  call add(l:groupdef, '  autocmd!')
  for [l:name, l:spec] in items(a:configuration.packages)
    if s:needs_loader(l:name, a:configuration)
      let l:item_code = s:gen_autoload_item(l:name, a:configuration)
      if unpack#solv#is_optional(l:name, a:configuration)
        call extend(l:output.autoload.unpack.loader, l:item_code.loader)
      else
        call extend(l:output.plugin.unpack, l:item_code.loader)
      endif
      call extend(l:groupdef, l:item_code.groupdef)
      if !empty(l:spec.ft)
        if !unpack#solv#has_dependents(l:name, a:configuration)
          let l:ft_code = s:gen_ft_item(l:name, a:configuration)
          for [l:ft, l:code] in items(l:ft_code)
            if has_key(l:output.ftplugin, l:ft)
              call extend(l:output.ftplugin[l:ft], l:code)
            else
              let l:output.ftplugin[l:ft] = ['" autogenerated by unpack#compile()']
              call extend(l:output.ftplugin[l:ft], l:code)
            endif
          endfor
        else
          let l:loader_code = s:gen_loader(a:name, a:configuration)
          let l:loader_cmd = 'call unpack#loader#' . s:rename(l:name) . '()'
          for l:ft in l:spec.ft
            let l:output.groupdef = s:gen_aucmds(['Filetype', l:ft, l:loader_cmd])
          endfor
        endif
      endif
    endif
  endfor
  call add(l:groupdef, 'augroup END')
  call add(l:output.plugin.unpack, '" place-holder to bypass calling unpack')
  call add(l:output.plugin.unpack, 'function! unpack#begin()')
  call add(l:output.plugin.unpack, 'endfunction')
  call add(l:output.plugin.unpack, 'function! unpack#end()')
  call add(l:output.plugin.unpack, 'endfunction')
  call add(l:output.plugin.unpack, 'command! -nargs=+ Unpack echo ""')
  if len(l:groupdef) > 3
    call extend(l:output.plugin.unpack, l:groupdef)
  endif
  return l:output
endfunction
