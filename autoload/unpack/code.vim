function! s:gen_augroup(name, defs)
  let l:output = []
  for [l:type, l:filters, l:cmd] in a:defs
    for l:filter in l:filters
      call add(l:output, '  autocmd ' . l:type . ' ' . l:filter . ' ' . l:cmd)
    endfor
  endfor
  return l:output
endfunction

function! s:gen_pre_post(cmd, ...)
  let l:padding = a:0 ? repeat(' ', a:1) : ''
  if a:cmd ==# ''
    return []
  else
    if stridx(a:cmd, '"')
      return [l:padding . "execute '" . a:cmd . "'"]
    else
      return [l:padding . 'execute "' . a:cmd . '"']
    endif
  endif
endfunction

" rename package names that contain '.' and '-' to '_'
function! s:rename(name)
  return substitute(tolower(a:name), '\(\.\|-\)', '_', 'g')
endfunction

function! s:gen_optional_loader(name, spec)
  let l:output = []
  let l:name = s:rename(a:name)
  let l:flag = 'g:unpack_loader_' . l:name . '_init_status'
  call add(l:output, '  if !' . l:flag)
  call add(l:output, '    let ' . l:flag . ' = 1')
  call extend(l:output, s:gen_pre_post(a:spec['pre'], 4))
  call add(l:output, "    execute 'packadd " . a:name . "'")
  call extend(l:output, s:gen_pre_post(a:spec['post'], 4))
  call add(l:output, '  endif')
  return l:output
endfunction

function! s:gen_loader(name, spec)
  let l:output = []
  " we use ftplugins for filetype options to save on overhead
  if !empty(a:spec.cmd) || !empty(a:spec.event)
    let l:name = s:rename(a:name)
    let l:flag = 'g:unpack_loader_' . l:name . '_init_status'
    call add(l:output, 'let ' . l:flag . ' = 0')
    call add(l:output, 'function! unpack#loader#' . l:name . '()')
    call extend(l:output, s:gen_optional_loader(a:name, a:spec))
    call add(l:output, 'endfunction')
  elseif empty(a:spec.ft)
    if a:spec['pre'] !=# ''
      call extend(l:output, s:gen_pre_post(a:spec['pre']))
      call add(l:output, "execute 'packadd " . a:name . "'")
    endif
    call extend(l:output, s:gen_pre_post(a:spec['post']))
  endif
  return l:output
endfunction

function! s:gen_cmd_item(name, spec)
  let l:defs = []
  let l:name = s:rename(a:name)
  let l:loader_cmd = 'call unpack#loader#' . l:name . '()'

  if !empty(a:spec.cmd)
    call add(l:defs, ['CmdUndefined', a:spec.cmd, l:loader_cmd])
  endif

  for l:event in a:spec.event
    call add(l:defs, [l:event, ['*'], l:loader_cmd])
  endfor

  let l:output = {}
  let l:output.loader = s:gen_loader(a:name, a:spec)
  let l:output.groupdef = s:gen_augroup(toupper(l:name), l:defs)
  return l:output
endfunction

function! s:gen_ft_item(name, spec)
  let l:output = {}
  for l:ft in a:spec.ft
    "                                                               remove indentation
    let l:output[l:ft] = map(s:gen_optional_loader(a:name, a:spec), {_, s -> s[2:]})
  endfor
  return l:output
endfunction

function! s:needs_loader(spec)
  return a:spec['post'] !=# '' || a:spec['pre'] !=# '' || s:is_optional(a:spec)
endfunction

function! s:is_optional(spec)
  return !empty(a:spec.ft) || !empty(a:spec.cmd) || !empty(a:spec.event)
endfunction

function! unpack#code#gen(configuration)
  let l:output = {
        \   'plugin': { 'unpack': [] },
        \   'ftplugin': {},
        \   'autoload': { 'unpack': { 'loader': [] } }
        \ }
  call add(l:output.plugin.unpack, '" autogenerated by unpack#compile()')
  call add(l:output.autoload.unpack.loader, '" autogenerated by unpack#compile()')
  if g:unpack#packpath_modified
    call add(l:output.plugin.unpack, 'set packpath+=' . g:unpack#packpath)
  endif
  let l:groupdef = []
  call add(l:groupdef, 'augroup UNPACK_AUTOLOAD')
  call add(l:groupdef, '  autocmd!')
  for [l:name, l:spec] in items(a:configuration.packages)
    if s:needs_loader(l:spec)
      let l:item_code = s:gen_cmd_item(l:name, l:spec)
      if s:is_optional(l:spec)
        call extend(l:output.autoload.unpack.loader, l:item_code.loader)
      else
        call extend(l:output.plugin.unpack, l:item_code.loader)
      endif
      call extend(l:groupdef, l:item_code.groupdef)
      if !empty(l:spec.ft)
        let l:ft_code = s:gen_ft_item(l:name, l:spec)
        for [l:ft, l:code] in items(l:ft_code)
          if has_key(l:output.ftplugin, l:ft)
            call extend(l:output.ftplugin[l:ft], l:code)
          else
            let l:output.ftplugin[l:ft] = [' autogenerated by unpack#compile()']
            call extend(l:output.ftplugin[l:ft], l:code)
          endif
        endfor
        " status flag needs to be initialized if there's no cmd/event specific
        " triggers
        if empty(l:spec.cmd) && empty(l:spec.event)
          let l:init = 'let g:unpack_loader_' . s:rename(l:name) . '_init_status = 0'
          call add(l:output.autoload.unpack.loader, l:init)
        endif
      endif
    endif
  endfor
  call add(l:groupdef, 'augroup END')
  call add(l:output.plugin.unpack, '" place-holder to bypass calling unpack')
  call add(l:output.plugin.unpack, 'function! unpack#begin()')
  call add(l:output.plugin.unpack, 'endfunction')
  call add(l:output.plugin.unpack, 'function! unpack#end()')
  call add(l:output.plugin.unpack, 'endfunction')
  call add(l:output.plugin.unpack, 'command! -nargs=+ Unpack echo ""')
  if len(l:groupdef) > 3
    call extend(l:output.plugin.unpack, l:groupdef)
  endif
  return l:output
endfunction
